package com.company;

import java.io.*;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;


public class Main {

    public static void main(String[] args) throws FileNotFoundException {
            Scanner scanner = new Scanner(System.in);
            System.out.println("""
                    MyFS 1.0 команды:
                    ls <path>               выводит список всех файлов и директорий для `path`
                    ls_py <path>            выводит список файлов с расширением `.py` в `path`
                    is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`
                    define <path>           выводит `директория` или `файл` в зависимости от типа `path`
                    readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя
                    setmod <path> <perm>    устанавливает права для файла `path`
                    cat <path>              выводит контент файла
                    append <path>           добавляет строку `# Autogenerated line` в конец `path`
                    bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`
                    greplong <path>         выводит самое длинное слово в файле
                    help                    выводит список команд и их описание
                    exit                    завершает работу программы
                    """);
            while (true) {
                System.out.print("=> ");
                String input = scanner.nextLine();

                if (input.length() == 0) {
                    continue;
                }

                if (input.equals("exit")) {
                    exit();
                    break;
                } else if (input.equals("help")) {
                    help();
                } else {
                    String[] splittingCommand = input.split(" ");
                    if(splittingCommand.length <= 1){
                        System.out.println("Введите правильную команду.");
                        continue;
                    } else {
                        String command = splittingCommand[0];
                        String path = splittingCommand[1];
                        if (command.equals("ls")) {
                            listDirectory(path);
                        } else if (command.equals("ls_py")) { //?
                            listPythonFiles(path);
                        } else if (command.equals("is_dir")) {
                            isDirectory(path);
                        } else if (command.equals("define")) {
                            define(path);
                        } else if (command.equals("readmod")) {
                            printPermissions(path);
                        } else if (command.equals("setmod")) {
                            setPermissions(path, splittingCommand[2]);
                        } else if (command.equals("cat")) {
                            printContent(path);
                        } else if (command.equals("append")) {
                            appendFooter(path);
                        } else if (command.equals("bc")) {
                            createBackup(path);
                        } else if (command.equals("greplong")) {
                            printLongestWord(path);
                        } else {
                            System.out.println("Данной команды не существует или нету в нашем функционале. Попробуйте заново в рамках нашего функционала.");
                            continue;
                        }
                    }
                }
            }
        }


        public static void listDirectory(String path) {
            File dir = new File(path);
            if(!dir.exists()){
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
                return;
            }
            else {
                String[] list = dir.list();
                for (String s : list) {
                    System.out.println(s);
                }
            }

        }

        public static void listPythonFiles(String path) {
            File dir = new File(path);
            if(dir.exists()) {
                for (File item : dir.listFiles()) {
                    if (item.getName().endsWith(".py")) {
                        System.out.println(item.getName());
                    }
                }
            }
            else{
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
            }
        }

        public static void isDirectory(String path) {
            File dir = new File(path);
            if(dir.exists()){
                System.out.println(dir.isDirectory());
            }
        }


        public static void define(String path) {
            File dir = new File(path);
            if(!dir.exists()){
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
                return;
            }
            if (dir.isDirectory()) {
                System.out.println("Директория");
            } else if (dir.isFile()) {
                System.out.println("Файл");
            }

        }

        public static void printPermissions(String path) {
            File dir = new File(path);

            if (dir.exists()) {
                String answer = "";
                if (dir.canRead()) {
                    answer += "r";
                } else {
                    answer += "-";
                }
                if (dir.canWrite()) {
                    answer += "w";
                } else {
                    answer += "-";
                }
                if (dir.canExecute()) {
                    answer += "x";
                } else {
                    answer += "-";
                }
                System.out.println(answer);
            }
            else{
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
                return;
            }
        }

        public static void setPermissions(String path, String permissions) {
            File dir = new File(path);
            if (dir.exists()) {
                if (permissions.contains("r")) { //Здесь я склоняюсь к тому что при добавлении прав легче писать права сразу как в линуксе rwx, и например если написать -wx или просто wx то права на файл перезапишутся в виде -wx. Могу и по другому реализовать, просто в описании задачи нет конкретики.
                    dir.setReadable(true);
                } else {
                    dir.setReadable(false);
                }
                if (permissions.contains("w")) {
                    dir.setWritable(true);
                } else {
                    dir.setWritable(false);
                }
                if (permissions.contains("x")) {
                    dir.setExecutable(true);
                } else {
                    dir.setExecutable(false);
                }
            }
            else{
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
                return;
            }
        }

        public static void printContent(String path) throws FileNotFoundException {
            File dir = new File(path);
            if(dir.exists()) {
                Scanner obj = new Scanner(dir);
                while (obj.hasNextLine()) {
                    System.out.println(obj.nextLine());
                }
            }
            else{
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
                return;
            }
        }

        public static void appendFooter(String path) {
            try {
                FileWriter fr = new FileWriter(path, true);
                fr.write("\n`# Autogenerated line`");
                fr.close();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }



        public static void createBackup(String path){
            File file = new File(path);
            Date date = new Date();
            SimpleDateFormat formatter = new SimpleDateFormat("dd-MM-yyyy");
            String rightDate= formatter.format(date);
            String backupDestinationDirectory = "/tmp/" + rightDate + ".backup";
            File destinationFolder = new File(backupDestinationDirectory);
            //T
            if (file.exists()) {
                return;
            }
            if(destinationFolder.exists()) {
                try {
                    deleteDirectoryRecursion(destinationFolder.toPath());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if(file.isFile()) {
                destinationFolder.mkdir();
                try {
                    InputStream in = new BufferedInputStream(new FileInputStream(file));
                    OutputStream out = new BufferedOutputStream(new FileOutputStream(destinationFolder + "/" + file.getName()));
                    byte[] buffer =new byte[1024];
                    int len;
                    while ((len = in.read(buffer)) > 0) {
                        out.write(buffer,0,len);
                        out.flush();
                    }
                }catch (IOException e) {
                    e.printStackTrace();
                }
                return;
            }

            Path sourcePath = file.toPath();
            Path destPath = destinationFolder.toPath();

            try {
                Files.walk(sourcePath).forEach((s) -> copy(s, destPath.resolve(sourcePath.relativize(s))));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private static void deleteDirectoryRecursion(Path path) throws IOException {
            if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
                try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
                    for (Path entry : entries) {
                        deleteDirectoryRecursion(entry);
                    }
                }
            }
            Files.delete(path);
        }
        private static void copy(Path source, Path dest) {
            try {
                Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }



        public static void printLongestWord(String path) throws FileNotFoundException {
            String longest_word = "";
            String current;
            File file = new File(path);
            if(file.exists()) {
                Scanner dir = new Scanner(file);
                while (dir.hasNext()) {
                    current = dir.next();
                    if (current.length() > longest_word.length()) {
                        longest_word = current;
                    }
                }

                System.out.println(longest_word);
            }
            else{
                System.out.println("Указанный путь не существует. Запустите программу заново и введите верный путь. Для помощи введите help.");
            }
        }

        public static void help() {
            System.out.println("""
                            MyFS 1.0 команды:
                            ls <path>               выводит список всех файлов и директорий для `path`
                            ls_py <path>            выводит список файлов с расширением `.py` в `path`
                            is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`
                            define <path>           выводит `директория` или `файл` в зависимости от типа `path`
                            readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя
                            setmod <path> <perm>    устанавливает права для файла `path`
                            cat <path>              выводит контент файла
                            append <path>           добавляет строку `# Autogenerated line` в конец `path`
                            bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`
                            greplong <path>         выводит самое длинное слово в файле
                            help                    выводит список команд и их описание
                            exit                    завершает работу программы
                            """);
        }

        public static void exit() {
            System.out.println("Good BYE");
        }
    }
